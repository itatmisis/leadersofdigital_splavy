# -*- coding: utf-8 -*-
"""mrcnn_reference.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B3Ml5mTcWx1nnyeLSEf1JvoSBty-pxVK
"""

import datetime
import os
from pathlib import Path
from sqlite3 import Error

import cv2
import numpy as np
from numpy import array
from shapely.geometry import Polygon, asPoint

import mrcnn.config
from mrcnn.model import MaskRCNN
from mrcnn.visualize import display_instances
import pandas as pd
import math

class_names = ['BG', 'person', 'bicycle', 'car', 'motorcycle', 'airplane',
               'bus', 'train', 'truck', 'boat', 'traffic light',
               'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird',
               'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear',
               'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie',
               'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
               'kite', 'baseball bat', 'baseball glove', 'skateboard',
               'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup',
               'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
               'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza',
               'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed',
               'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote',
               'keyboard', 'cell phone', 'microwave', 'oven', 'toaster',
               'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors',
               'teddy bear', 'hair drier', 'toothbrush']


class MaskRCNNConfig(mrcnn.config.Config):
    NAME = "coco_pretrained_model_config"
    IMAGES_PER_GPU = 1
    GPU_COUNT = 1
    NUM_CLASSES = 1 + 80  # COCO dataset has 80 classes + one background class
    DETECTION_MIN_CONFIDENCE = 0.5


class Occupancy:
    def __init__(self, path):
        self.model = self.get_model(path)


    def get_model(self, path):
        model = MaskRCNN(mode="inference", model_dir='/content/out', config=MaskRCNNConfig())
        model.load_weights(path, by_name=True)
        return model


    def get_car_boxes(self, boxes, class_ids):
        car_boxes = []
        
        for i, box in enumerate(boxes):
            # If the detected object isn't a car / truck, skip it
            if class_ids[i] in [3]:
                car_boxes.append(box)

        return np.array(car_boxes)


    def get_car_boxes(self, boxes, class_ids):
        car_boxes = []

        for i, box in enumerate(boxes):
            # If the detected object isn't a car / truck, skip it
            if class_ids[i] in [3]:
                car_boxes.append(box)

        return np.array(car_boxes)


    def predict(self, path_to_image):
        model = self.model
        # Clone image instead of using original
        frame_copy = cv2.imread(path_to_image)
        # Convert the image from BGR color (which OpenCV uses) to RGB color
        rgb_image = frame_copy[:, :, ::-1]
        print("Starting Mask R-CNN segmentation and detection...")
        # Run the image through the Mask R-CNN model to get results.
        results = model.detect([rgb_image], verbose=0)
        r = results[0]
        car_boxes = self.get_car_boxes(r['rois'], r['class_ids'])
        print("Cars found in frame: {}".format(len(car_boxes)))
        return car_boxes


    def occupied(self, path_to_image, centers):
        car_boxes = self.predict(path_to_image)
        box_centers = [((box[1]+box[3])/2, (box[0]+box[2])/2) for box in car_boxes]
        results = {'parking_id':[],
                   'parking_slot_id':[],
                   'x1':[],
                   'y1':[],
                   'busy':[]
                   }

        for i, row in centers.iterrows():
            rects=[]
            
            color = 1
            for index, box in enumerate(car_boxes):
                if box[1] < row['x1'] < box[3] and box[0] < row['y1'] < box[2]:
                    rects.append([index, box])
            if len(rects) == 0:
                color = 0
            else:
                if len(rects) > 1:
                    box_ = None
                    index_ = None
                    min_dist=100000
                    for index, ibox in rects:
                        dist = math.sqrt((box_centers[index][0] - row['x1'])**2 + (box_centers[index][1] - row['y1'])**2)
                        if dist < min_dist:
                            box_ = ibox
                            min_dist = dist
                            index_ = index
                else:
                    box_ = rects[0][1]
                    index_ = rects[0][0]
                l = min(box_[3] - box_[1], box_[2] - box_[0])
                r = math.ceil(4/7 * l)
                if (box_centers[index_][0] - row['x1'])**2 + (box_centers[index_][1] - row['y1'])**2 <= r**2:
                    color = 1
                else:
                    color = 0
            results['parking_id'].append(row['parking_id'])
            results['parking_slot_id'].append(row['parking_slot_id'])
            results['x1'].append(row['x1'])
            results['y1'].append(row['y1'])
            results['busy'].append(color)
        return results

# model = Occupancy(PATH_TO_WEIGHTS)
# data = pd.DataFrame(data=model.occupied(PATH_TO_IMAGE, pd.DataFrame(PATH_TO_CENTERS)))

